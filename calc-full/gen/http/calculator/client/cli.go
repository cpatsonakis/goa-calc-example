// Code generated by goa v3.10.1, DO NOT EDIT.
//
// calculator HTTP client CLI support package
//
// Command:
// $ goa gen github.com/cpatsonakis/goa-calc-example/design/calc-full -o
// calc-full

package client

import (
	"fmt"
	"strconv"

	calculator "github.com/cpatsonakis/goa-calc-example/calc-full/gen/calculator"
)

// BuildAddPayload builds the payload for the calculator add endpoint from CLI
// flags.
func BuildAddPayload(calculatorAddA string, calculatorAddB string) (*calculator.AdditionPayload, error) {
	var err error
	var a int64
	{
		a, err = strconv.ParseInt(calculatorAddA, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for a, must be INT64")
		}
	}
	var b int64
	{
		b, err = strconv.ParseInt(calculatorAddB, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for b, must be INT64")
		}
	}
	v := &calculator.AdditionPayload{}
	v.A = a
	v.B = b

	return v, nil
}

// BuildSubtractPayload builds the payload for the calculator subtract endpoint
// from CLI flags.
func BuildSubtractPayload(calculatorSubtractA string, calculatorSubtractB string) (*calculator.SubtractionPayload, error) {
	var err error
	var a int64
	{
		a, err = strconv.ParseInt(calculatorSubtractA, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for a, must be INT64")
		}
	}
	var b int64
	{
		b, err = strconv.ParseInt(calculatorSubtractB, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for b, must be INT64")
		}
	}
	v := &calculator.SubtractionPayload{}
	v.A = a
	v.B = b

	return v, nil
}

// BuildMultiplyPayload builds the payload for the calculator multiply endpoint
// from CLI flags.
func BuildMultiplyPayload(calculatorMultiplyA string, calculatorMultiplyB string) (*calculator.MultiplicationPayload, error) {
	var err error
	var a int64
	{
		a, err = strconv.ParseInt(calculatorMultiplyA, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for a, must be INT64")
		}
	}
	var b int64
	{
		b, err = strconv.ParseInt(calculatorMultiplyB, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for b, must be INT64")
		}
	}
	v := &calculator.MultiplicationPayload{}
	v.A = a
	v.B = b

	return v, nil
}

// BuildDividePayload builds the payload for the calculator divide endpoint
// from CLI flags.
func BuildDividePayload(calculatorDivideA string, calculatorDivideB string) (*calculator.DivisionPayload, error) {
	var err error
	var a int64
	{
		a, err = strconv.ParseInt(calculatorDivideA, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for a, must be INT64")
		}
	}
	var b int64
	{
		b, err = strconv.ParseInt(calculatorDivideB, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for b, must be INT64")
		}
	}
	v := &calculator.DivisionPayload{}
	v.A = a
	v.B = b

	return v, nil
}
